<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"> 

<title>Ray Tracing in GPU</title>

<script type="text/javascript" src="../../common/webgl-utils.js"></script>
<script type="text/javascript" src="../../common/initShaders.js"></script>
<script type="text/javascript" src="../../common/MV.js"></script>
<script type="text/javascript" src="../../common/Trackball.js"></script>
<script type="text/javascript" src="../../common/Camera.js"></script>
<script type="text/javascript" src="../../common/Object.js"></script>
<script type="text/javascript" src="../../common/Utils.js"></script>

<script type="text/javascript" src="RayTracerGPU.js"></script> 

<script id="vertex-shader" type="x-shader/x-vertex">
precision highp float;
attribute vec4 vPosition;
attribute vec3 vNormal;

uniform mat4 M, TB, VP;
uniform mat3 N, TBN;
uniform vec3 Ka, Kd, Ks, Ia, Id, Is, lightPosition, cameraPosition;
uniform float shininess;
uniform float time;
varying vec4 v;


varying vec3 fNormal, fPosition;

float sumOfSines(float x, float y){
  float s = 0.0;
  s += 0.3*sin(4.0*x + 2.0*y);
  s+= -0.3*sin(6.0*x + 0.6*y);
  s+= -0.2*sin(4.0*y - 3.1*x);
  s+= 0.1*sin(8.0*x - 5.0*y);
  return 0.1*s;
}

float f(float x, float y){
    float r = sqrt(x*x + y*y);
    //return sinc(15.0*r);
    //return sinc(30.0*r)*sin(r-0.5*t);
    return sumOfSines(x,y);
}

vec3 computeNormal(float x, float y){
  float delta = 0.01;
  float dfdx = (f(x+delta, y) - f(x,y))/delta;
  float dfdy = (f(x, y+delta) - f(x,y))/delta;
  return vec3(-dfdx,-dfdy, 1.0);
}

float sinc(float x){
    if(x==0.0) return 1.0;
    return sin(x)/x;
}

void main() {
	v = vPosition;
	// v.z = f(v.x,v.y,time);

	vec3 vn = vNormal; // useless line just so that the optimizer doesn't remove vNormal.

	vec3 n = computeNormal(v.x, v.y);

	vec4 wPos = TB*M*vPosition; // world position
	
	v = VP*wPos;   
	v.z = -v.z;  // compensate for left handed coordinate system used by WebGL
	gl_Position = v;

	fPosition = wPos.xyz;
	fNormal = TBN*N*n;
}


</script>

<script id="fragment-shader" type="x-shader/x-fragment">
#define PI 3.1415926535897932384626433832795
precision highp float;

uniform vec3 Ka, Kd, Ks, Ia, Id, Is, lightPosition, cameraPosition;
uniform float shininess;

varying vec4 fColor, v;
varying vec3 fPosition, fNormal;
const int trace_depth = 2;


struct Ray {
  vec3 o; //origin
  vec3 d; //direction (should always be normalized)
};

struct Sphere {
  vec3 center;
  float radius;
  int material_id;
};

struct Camera {
  vec3 pos;   //camera position
  vec3 up;
  vec3 aim;   //view target
  float fov;  //field of view
};

struct hitObject {
  Sphere obj;
  vec3 point;
  float t;
};

struct Light {
  vec3 position;   //camera position
  float intensity;
  vec3 color;   //view target
};

struct Material {
  vec3 color;   //camera position
  float reflectivity;
  float shininess;   //view target
};

Sphere objects[2];
Light lights[2];
Material materials[2];
vec3 ambient_light = vec3(0.5,0.5,0.5);
vec3 background_color = vec3(0.0,0.0,0.0);
Camera camera;

/**
 * [intersect description]
 * @param  {[type]} Ray    ray           [description]
 * @param  {[type]} Sphere sphere        [description]
 * @return {[type]}        [description]
 */
float intersect(Ray ray, Sphere sphere) {
  float t, t1, t2; //
  vec3 x = ray.o - sphere.center; // vec from sphere center to ray origin
  float A = dot(ray.d, ray.d); //size^2
  float B = 2.0 * dot(x, ray.d); // 
  float C = dot(x,x) - sphere.radius * sphere.radius;
  float D = B*B - 4.0*A*C; //b^2 -4ac
  t = 99999.99;
  if (D >= 0.0){
    float S = sqrt(D); //sqrt(b^2-4ac)
    t1 = (-B - S)/(2.0 * A);
    t2 = (-B + S)/(2.0 * A);
    if (t1 >= 0.0){
      t = t1;
    }
    if (t2 >= 0.0 && t2 < t1 ){
      t = t2;
    }
  }
  return t;
}

/**
 * Finds the closest object that the given ray hits.
 * @param  {Ray} ray           ray with origin and direction
 * @return {hitObject}     object that is closest to the camera
 */
hitObject hit(Ray ray) {
  float x;
  float t = 99999.99;
  Sphere obj;
  vec3 point;

  for (int i = 0; i < 2; i++){
    x = intersect(ray, objects[i]);
    if (x >= 0.0 && x < t) {
      obj = objects[i];
      t = x;
    }
  }

  if(t < 9999999.99){
    point = ray.o + t*ray.d;
  }

  hitObject theSphere = hitObject(obj, point, t);

  return theSphere;
}

/**
 * Calculated direction of ray shot from camera towards each fragment
 * @param  {float} float x             x coordinate
 * @param  {float} float y             y coordinate
 * @return {Ray}       ray shot from camera towards each fragment
 */
Ray pixelRay(float x, float y) {
  // invert y
  y = 2.0 - y;
  // distance to near plane i.e., projection plane
  float n = 1.0;
  // width over height
  float aspect = 1.0;
  float fov_radians = camera.fov * PI / 180.0;
  float t = n * tan(fov_radians / 2.0);
  float r = t * aspect;
  float b = -t;
  float l = -r;

  // compute camera basis 
  vec3 w = normalize(camera.pos - camera.aim);
  vec3 u = normalize(cross(camera.up, w));
  vec3 v = cross(w,u);

  float ucomp = l + (r-l)*(x+0.5)/2.0;
  float vcomp = b + (t-b)*(y+0.5)/2.0;
  float wcomp = -n;

  vec3 raydir = ucomp * u;
  raydir = raydir + (vcomp * v);
  raydir = raydir + (wcomp * w);

  Ray Saurabh = Ray(camera.pos, normalize(raydir)); //in recognition of our professor Saurabh Ray
  return Saurabh;
}

/**
 * Calculates what color a given fragment (on an object) is
 * @param  {vec3}      position      position in 3D of the position where the ray hit the object
 * @param  {vec3}      normal        normal calculated at given position
 * @param  {vec3}      viewDir       viewing direction
 * @param  {Material}  material      material of object at given position
 * @return {vec3}          color of object at given position
 */
vec3 shade(vec3 position, vec3 normal, vec3 viewDir, Material material) {
  Light l;
  vec3 toLight, lightDir;
  vec3 halfvector;
  float shininess = material.shininess;
  vec3 color = material.color;

  vec3 diffuse = ambient_light;
  vec3 final_color = vec3(1.0,0,0);
  vec3 specular = vec3(0,1.0,0);

  for (int i = 0; i < 2; i++) {
    l = lights[i];
    toLight = l.position - position;
    lightDir = normalize(toLight);

    Ray shadowRay = Ray(position, lightDir);

    if (hit(shadowRay).t > length(toLight)) {
      float diffuseIntensity = l.intensity * max(dot(lightDir, normal), 0.0);
      diffuse = diffuse + diffuseIntensity * l.color;
      halfvector = normalize(viewDir + lightDir);
      float specularIntensity = pow(max(dot(halfvector, normal), 0.0), shininess);
      specular = specular + specularIntensity * l.color;
    }
  }

  final_color = final_color + diffuse * color;
  final_color = final_color + specular;

  return final_color;
}

vec3 computeNormal(vec3 center, vec3 point) {
  return normalize(point - center);
}

vec3 trace(Ray ray) {
  hitObject h;
  vec3 final_color = vec3(0.0, 0.0, 0.0);
  bool no_hit = true;
  float r = 1.0;

  if (trace_depth == 0) {
    return background_color;
  }

  for (int i = 0; i < trace_depth; i++) {
    h = hit(ray);
    if (h.obj.radius > 0.0) {
      no_hit = false;
      vec3 normal = computeNormal(h.obj.center, h.point);
      Material material = materials[0];
      // Material material = materials[h.obj.material_id];
      vec3 viewDir = -1.0 * ray.d;
      vec3 color = shade(h.point, normal, viewDir, material);

      vec3 reflected_dir = ray.d + (-2.0 * dot(ray.d, normal) * normal);
      Ray ray = Ray(h.point, reflected_dir);
      final_color = final_color + r * color;
      r *= material.reflectivity;
    }
  }

  if (no_hit) {
    return background_color;
  } else {
    return final_color;
  }
}

vec4 computeColor(vec3 position, vec3 normal) {
	// we are doing lighting in world coordinate frame

	vec3 lightDir = normalize(lightPosition - position);
	vec3 viewDir = normalize(cameraPosition - position);

	vec3 ambient = Ia*Ka ;
	vec3 diffuse = Id*Kd* max(0.0, dot(normal, lightDir));

	vec3 halfVector = normalize(lightDir + viewDir);
	vec3 specular = Is*Ks* pow( max(dot(halfVector, normal), 0.0), shininess);

	vec3 color = ambient + diffuse + specular;

	return vec4(color, 1.0);
}

void main(){
  // vec3 lightPos = vec3(1.0, 1.0, 1.0);
  camera = Camera(vec3(0.0, 0.0, 3.6), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 60.0);   //view target

  Sphere sphere0 = Sphere(vec3(-0.6,0.6,1.5), 0.2, 0);
  Sphere sphere1 = Sphere(vec3(0.0,0.0,0.0), 1.0, 1);
  objects[0] = sphere0;
  objects[1] = sphere1;

  Material material0 = Material(vec3(1.0,0.0,1.0), 0.2, 100.0);
  Material material1 = Material(vec3(0.8,0.8,0.8), 0.8, 2000.0);
  materials[0] = material0;
  materials[1] = material1;

  Light lights0 = Light(vec3(0.0,10.0,0.0), 5.0, vec3(1.0, 0.5,0.5));
  Light lights1 = Light(vec3(0.0,10.0,10.0), 5.0, vec3(1.0, 0.5,0.5));
  lights[0] = lights0;
  lights[1] = lights1;
  gl_FragColor = vec4(trace(pixelRay(fPosition.x, fPosition.y)),1.0);
	// gl_FragColor = computeColor(fPosition, normalize(fNormal));

}
</script>
</head>
<body>
   <canvas id="gl-canvas" width="512" height="512">
    HTML5 Canvas not supported!
   </canvas>
</body>
</html>

