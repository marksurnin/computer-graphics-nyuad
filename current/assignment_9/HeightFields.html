<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"> 

<title>Load Model</title>

<script type="text/javascript" src="../../common/webgl-utils.js"></script>
<script type="text/javascript" src="../../common/initShaders.js"></script>
<script type="text/javascript" src="../../common/MV.js"></script>
<script type="text/javascript" src="../../common/Trackball.js"></script>
<script type="text/javascript" src="../../common/Camera.js"></script>
<script type="text/javascript" src="../../common/Object.js"></script>
<script type="text/javascript" src="../../common/Utils.js"></script>

<script type="text/javascript" src="HeightFields.js"></script> 

<script id="vertex-shader" type="x-shader/x-vertex">
#define M_PI 3.1415926535897932384626433832795
precision highp float;
attribute vec4 vPosition;
attribute vec3 vNormal;

uniform mat4 M, TB, VP;
uniform mat3 N, TBN;
uniform vec3 Ka, Kd, Ks, Ia, Id, Is, lightPosition, cameraPosition;
uniform float shininess;
uniform float time;

varying vec3 fNormal, fPosition;

struct Ray {
  vec3 o; //origin
  vec3 d; //direction (should always be normalized)
};

struct Sphere {
  vec3 center;
  float radius;
  int material_id;
};

struct Camera {
  vec3 pos;   //camera position
  vec3 up;
  vec3 aim;   //view target
  float fov;  //field of view
};

vec3 lightPos = vec3(1.0, 1.0, 1.0);

Sphere sphere1 = Sphere(vec3(-0.6,0.6,1.5), 0.2, 0);
Camera camera = Camera(vec3(0.0, 0.0, 3.6), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0), 60.0);   //view target

Ray pixelRay(float x, float y) {
  // invert y
  y = 2.0 - y;
  // distance to near plane i.e., projection plane
  float n = 1.0;
  // width over height
  float aspect = 1.0;
  float fov_radians = camera.fov * M_PI / 180.0;
  float t = n * tan(fov_radians / 2.0);
  float r = t * aspect;
  float b = -t;
  float l = -r;

  // compute camera basis 
  vec3 w = normalize(camera.pos - camera.aim);
  vec3 u = normalize(cross(camera.up, w));
  vec3 v = cross(w,u);

  float ucomp = l + (r-l)*(x+0.5)/2.0;
  float vcomp = b + (t-b)*(y+0.5)/2.0;
  float wcomp = -n;

  vec3 raydir = ucomp * u;
  raydir = raydir + (vcomp * v);
  raydir = raydir + (wcomp * w);

  Ray theRay = Ray(camera.pos, normalize(raydir));
  return theRay;
}

float sinc(float x){
    if(x==0.0) return 1.0;
    return sin(x)/x;
}

float sumOfSines(float x, float y){
	float s = 0.0;
	s += 0.3*sin(4.0*x + 2.0*y);
	s+= -0.3*sin(6.0*x + 0.6*y);
	s+= -0.2*sin(4.0*y - 3.1*x);
	s+= 0.1*sin(8.0*x - 5.0*y);
	return 0.1*s;
}

float f(float x, float y){
    float r = sqrt(x*x + y*y);
    //return sinc(15.0*r);
    //return sinc(30.0*r)*sin(r-0.5*t);
    return sumOfSines(x,y);
}


vec3 computeNormal(float x,float y){
	float delta = 0.01;
	float dfdx = (f(x+delta, y) - f(x,y))/delta;
	float dfdy = (f(x, y+delta) - f(x,y))/delta;
	return vec3(-dfdx,-dfdy, 1.0);
}

void main(){
	vec4 v = vPosition;
	// v.z = f(v.x,v.y,time);

	vec3 vn = vNormal; // useless line just so that the optimizer doesn't remove vNormal.

	vec3 n = computeNormal(v.x, v.y);

	vec4 wPos = TB*M*v; // world position
	
	v = VP*wPos;   
	v.z = -v.z;  // compensate for left handed coordinate system used by WebGL
	gl_Position = v;

	fPosition = wPos.xyz;
	fNormal = TBN*N*n;
}


</script>

<script id="fragment-shader" type="x-shader/x-fragment">
precision highp float;

uniform vec3 Ka, Kd, Ks, Ia, Id, Is, lightPosition, cameraPosition;
uniform float shininess;

varying vec4 fColor;
varying vec3 fPosition, fNormal;

vec4 computeColor(vec3 position, vec3 normal) {
	// we are doing lighting in world coordinate frame

	vec3 lightDir = normalize(lightPosition - position);
	vec3 viewDir = normalize(cameraPosition - position);

	vec3 ambient = Ia*Ka ;
	vec3 diffuse = Id*Kd* max(0.0, dot(normal, lightDir));

	vec3 halfVector = normalize(lightDir + viewDir);
	vec3 specular = Is*Ks* pow( max(dot(halfVector, normal), 0.0), shininess);

	vec3 color = ambient + diffuse + specular;

	return vec4(color, 1.0);
}

void main(){
		gl_FragColor = computeColor(fPosition, normalize(fNormal));

}
</script>
</head>
<body>
   <canvas id="gl-canvas" width="512" height="512">
    HTML5 Canvas not supported!
   </canvas>
</body>
</html>

